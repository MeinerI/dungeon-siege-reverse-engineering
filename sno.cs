//ææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææ
  using System; using System.IO; using System.Linq; using System.Text; using System.Collections; 
  using System.Collections.Generic; using System.Text.RegularExpressions; using System.Globalization; 
//ææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææ

sealed class Test 
{
    private static SnoModel   model;
    private static float      modelScale = 1.0f;
    private static string     texFileNameExt = ".tga";

// ========================================================

    public static void Main()
    {
        SearchOption SOAD = SearchOption.AllDirectories;
        string[] filesName = Directory.GetFiles(Directory.GetCurrentDirectory(), "*.sno",  SOAD); 
        System.Threading.Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");

// ========================================================

        foreach (var file in filesName)
        {
	    using (BinaryReader br = new BinaryReader(File.Open(file, FileMode.Open)))
	    {
		string name = file.Replace(".sno","");
		using (StreamWriter objw = new StreamWriter(name + ".obj"))
		{
		using (StreamWriter mtlw = new StreamWriter(name + ".mtl"))
		{
                    Console.WriteLine("====== Beginning SNO import... ======");

                    model = new SnoModel();

                  //íóæíî ëè, åñëè îíè è òàê îá'null'ÿþòñÿ
                    model.spots.Clear();
                    model.doors.Clear();
                    model.corners.Clear();
                    model.surfaces.Clear();

                    model.readHeader(br);
                    model.readSpots(br);
                    model.readDoors(br);
                    model.readCorners(br);
                    model.readSurfaces(br);

                    Console.WriteLine("==== Finished importing SNO file ====\n");
                    
                //==========================================================

                //  objw.WriteLine("");

                    objw.WriteLine("# File generated by sno2obj from DSiege1 \'Siege Node\' \"" + file + "\".");
                    objw.WriteLine("mtllib " + name + ".mtl");

                    objw.WriteLine("o SiegeNode_" + name + "\n");

                    var corners = model.corners;

                    // Vertexes: //----------------------------------------------------------

                    foreach (var c in corners) {
                        Vec3 v = new Vec3 { 
                        x = (c.pos.x * modelScale),
                        y = -(c.pos.z * modelScale),
                        z = (c.pos.y * modelScale) };

                        objw.WriteLine("v " + v.x + " " + v.y + " " + v.z);
                    }   objw.WriteLine();

                    // Vertex normals: //----------------------------------------------------------

                    foreach (var c in corners) {
                      Vec3 n = c.normal;
                      objw.WriteLine("vn " + n.x + " " + n.y + " " + n.z);
                    } objw.WriteLine();

                    // Texture coordinates: //----------------------------------------------------------

                    foreach (var c in corners) {
                      Vec2 t = c.texCoord;
                      objw.WriteLine("vt " + t.u + " " + t.v);
                    } objw.WriteLine();
                
                    // Write face indexes: //----------------------------------------------------------

                    var surfaces   = model.surfaces;
                    var textureCount = model.header.textureCount;

                    for (int i = 0; i < textureCount; i++)
                    {
                      objw.WriteLine("g SnoMaterialGroup_" + i);
                      objw.WriteLine("usemtl " + surfaces[i].textureName);
                      objw.WriteLine("s 1"); // Allow smooth shading.

                      var faceCount = (surfaces[i].cornerCount / 3);

                        for (int j = 0; j < faceCount; j++)
                        {
                            var a = surfaces[i].faces[j].index[0] + surfaces[i].startCorner + 1;
                            var b = surfaces[i].faces[j].index[1] + surfaces[i].startCorner + 1;
                            var c = surfaces[i].faces[j].index[2] + surfaces[i].startCorner + 1; // +1 for the OBJ

                            // Position + texture + normal

                            objw.WriteLine("f " + a + "/" + a + "/" + a + " "
                                            + b + "/" + b + "/" + b + " "
                                            + c + "/" + c + "/" + c);
                        }
                    }

                    objw.WriteLine();

                    Console.WriteLine("OBJ Finished.");

                //==========================================================

                    Console.WriteLine("Writing MTL...");

                    for (int i = 0; i < textureCount; ++i)
                    {
                      var textureName = surfaces[i].textureName;

                      mtlw.WriteLine("newmtl " + textureName);
                      mtlw.WriteLine("Ka 0.00 0.00 0.00"); // Ambient
                      mtlw.WriteLine("Kd 1.00 1.00 1.00"); // Diffuse
                      mtlw.WriteLine("Ks 0.50 0.50 0.50"); // Specular
                      mtlw.WriteLine("Ns 95.00"); // Specular exponent/power
                      mtlw.WriteLine("map_Kd " + (textureName + texFileNameExt));
                    }
                    
                    Console.WriteLine("MTL Finished.");

                //==========================================================

		}//using sw
		}//using sw
            }//using br
        } // foreach (var file in filesName)
    } // public static void Main()
} // sealed class Test {

//ææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææ
//ææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææ
//ææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææ

public static class Str
{
    public static string readString(this BinaryReader input)
    {
        List<byte> strBytes = new List<byte>();
        int b;
        while ((b = input.ReadByte()) != 0x00)
            strBytes.Add((byte)b);
        return Encoding.ASCII.GetString(strBytes.ToArray());
    }
}

//ææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææ

sealed class SnoModel
{
  //Accepted value for `Header::version`.
    public const int VersionExpected = 7; // static constexpr 
//  public string srcFileName;
    public Header header = new Header();

    public List<SpotInfo>    spots = new List<SpotInfo>();
    public List<DoorInfo>    doors = new List<DoorInfo>();
    public List<CornerInfo>  corners = new List<CornerInfo>();
    public List<SurfaceInfo> surfaces = new List<SurfaceInfo>();

// ========================================================

    public void readHeader(BinaryReader br)
    {
  //    readBytes(&header, sizeof(SnoModel::Header));
  //    auto toHexa = [](uint32_t val) { return utils::format("0x%08X", val); };

        header.magic.c0 = br.ReadByte();
        header.magic.c1 = br.ReadByte();
        header.magic.c2 = br.ReadByte();
        header.magic.c3 = br.ReadByte();

        header.version = br.ReadInt32();

        if (header.version < VersionExpected) return;

        header.unused0 = br.ReadInt32();
        header.doorCount = br.ReadInt32();
        header.spotCount = br.ReadInt32();
        header.cornerCount = br.ReadInt32();
        header.faceCount = br.ReadInt32();
        header.textureCount = br.ReadInt32();

        header.minBBox.x = br.ReadSingle(); 
        header.minBBox.y = br.ReadSingle(); 
        header.minBBox.z = br.ReadSingle(); 

        header.maxBBox.x = br.ReadSingle(); 
        header.maxBBox.y = br.ReadSingle(); 
        header.maxBBox.z = br.ReadSingle(); 

        header.unused1 = br.ReadInt32();
        header.unused2 = br.ReadInt32();
        header.unused3 = br.ReadInt32();
        header.unused4 = br.ReadInt32();
        header.unused5 = br.ReadInt32();
        header.unused6 = br.ReadInt32();
        header.unused7 = br.ReadInt32();

        header.dataCrc32 = br.ReadInt32();

        Console.WriteLine();
        Console.WriteLine("header.magic.........: " + header.magic);
        Console.WriteLine("header.version.......: " + header.version);
        Console.WriteLine("header.unused0.......: " + header.unused0);
        Console.WriteLine("header.doorCount.....: " + header.doorCount);
        Console.WriteLine("header.spotCount.....: " + header.spotCount);
        Console.WriteLine("header.cornerCount...: " + header.cornerCount);
        Console.WriteLine("header.faceCount.....: " + header.faceCount);
        Console.WriteLine("header.textureCount..: " + header.textureCount);
  /*
        Console.WriteLine("header.minBBox.......: " + utils::toString(header.minBBox));
        Console.WriteLine("header.maxBBox.......: " + utils::toString(header.maxBBox));
        
        Console.WriteLine("header.unused1.......: " + toHexa(header.unused1));
        Console.WriteLine("header.unused2.......: " + toHexa(header.unused2));
        Console.WriteLine("header.unused3.......: " + toHexa(header.unused3));
        Console.WriteLine("header.unused4.......: " + toHexa(header.unused4));
        Console.WriteLine("header.unused5.......: " + toHexa(header.unused5));
        Console.WriteLine("header.unused6.......: " + toHexa(header.unused6));
        Console.WriteLine("header.unused7.......: " + toHexa(header.unused7));

        Console.WriteLine("header.dataCrc32.....: " + toHexa(header.dataCrc32));  */

      //if (header.magic != "SNOD")
        if ((header.magic.c0 != 'S')
        &&  (header.magic.c1 != 'N')
        &&  (header.magic.c2 != 'O')
        &&  (header.magic.c3 != 'D'))
            throw new Exception("SNO file is not a valid Siege Node! Bad header magic! " + header.magic);

        if (header.version < VersionExpected)
            throw new Exception("SNO file is not a version " + VersionExpected + " Siege Node! " + header.version);
    }

// ========================================================

    public void readSpots(BinaryReader br)
    {
        Console.WriteLine("\n====== readSpots() ======\n");

        if (header.spotCount == 0) 
        {
            Console.WriteLine("No spots.");
            return;
        }

      //spots.resize(header.spotCount);
        for (int oo = 0; oo < header.spotCount; oo++)
        spots.Add(new SpotInfo());

//try'ñÿ  SpotInfo[] si = new SpotInfo[header.spotCount];
//òàê     spots.AddRange(si.ToList());

        for (int s = 0; s < header.spotCount; ++s)
        {
          //readFloat4x3(model.spots[s].xform);

            // Rotation 3x3 matrix:
            spots[s].xform[0, 0] = br.ReadSingle(); 
            spots[s].xform[0, 1] = br.ReadSingle(); 
            spots[s].xform[0, 2] = br.ReadSingle(); 

            spots[s].xform[1, 0] = br.ReadSingle(); 
            spots[s].xform[1, 1] = br.ReadSingle(); 
            spots[s].xform[1, 2] = br.ReadSingle(); 

            spots[s].xform[2, 0] = br.ReadSingle(); 
            spots[s].xform[2, 1] = br.ReadSingle(); 
            spots[s].xform[2, 2] = br.ReadSingle(); 

            // Position/translation vector:
            spots[s].xform[3, 0] = br.ReadSingle(); 
            spots[s].xform[3, 1] = br.ReadSingle(); 
            spots[s].xform[3, 2] = br.ReadSingle(); 

            spots[s].name = br.readString();
            Console.WriteLine("Spot name: " + spots[s].name);
        }
            Console.WriteLine("\nRead " + header.spotCount + " spots.");
    }

// ========================================================

    public void readDoors(BinaryReader br)
    {
        Console.WriteLine("\n====== readDoors() ======");

        if (header.doorCount == 0)
        {
            Console.WriteLine("No doors.");
            return;
        }

//      doors.resize(header.doorCount);
        for (int oo = 0; oo < header.doorCount; oo++)
        doors.Add(new DoorInfo());

        for (int d = 0; d < header.doorCount; d++)
        {
            doors[d].index = br.ReadInt32();

            // Rotation 3x3 matrix:

            doors[d].xform[0, 0] = br.ReadSingle(); 
            doors[d].xform[0, 1] = br.ReadSingle(); 
            doors[d].xform[0, 2] = br.ReadSingle(); 

            doors[d].xform[1, 0] = br.ReadSingle(); 
            doors[d].xform[1, 1] = br.ReadSingle(); 
            doors[d].xform[1, 2] = br.ReadSingle(); 

            doors[d].xform[2, 0] = br.ReadSingle(); 
            doors[d].xform[2, 1] = br.ReadSingle(); 
            doors[d].xform[2, 2] = br.ReadSingle(); 

            // Position/translation vector:

            doors[d].xform[3, 0] = br.ReadSingle(); 
            doors[d].xform[3, 1] = br.ReadSingle(); 
            doors[d].xform[3, 2] = br.ReadSingle(); 

            int hotSpotCount = br.ReadInt32();
            
            Console.WriteLine("\nDoor index " + doors[d].index + " has " + hotSpotCount + " hot-spots.");

            if (hotSpotCount == 0) continue;

//          doors[d].hotSpots.resize(hotSpotCount);
            for (int oo = 0; oo < hotSpotCount; oo++)
            doors[d].hotSpots.Add(new int());

            for (int h = 0; h < hotSpotCount; h++)
            {
                doors[d].hotSpots[h] = br.ReadInt32();
                Console.WriteLine("Door[" + d + "].hotSpot[" + h + "] = " + doors[d].hotSpots[h]);
            }
        }
            Console.WriteLine("\nRead " + header.doorCount + " doors.");
    }

// ========================================================

    public void readCorners(BinaryReader br)
    {
        Console.WriteLine("\n====== readCorners() ====\n");

        if (header.cornerCount == 0)
        {
            Console.WriteLine("No corners.");
            return;
        }

        var mdlCorners = corners;

//      mdlCorners.resize(header.cornerCount);
        for (int oo = 0; oo < header.cornerCount; oo++)
        mdlCorners.Add(new CornerInfo());

        for (int c = 0; c < header.cornerCount; ++c)
        {
            mdlCorners[c].pos.x = br.ReadSingle(); 
            mdlCorners[c].pos.y = br.ReadSingle(); 
            mdlCorners[c].pos.z = br.ReadSingle(); 

            mdlCorners[c].normal.x = br.ReadSingle(); 
            mdlCorners[c].normal.y = br.ReadSingle(); 
            mdlCorners[c].normal.z = br.ReadSingle(); 

            // Swizzle back to RGBA (why the heck this insane layout??)

            var rrr = br.ReadByte();
            var bbb = br.ReadByte();
            var ggg = br.ReadByte();
            var aaa = br.ReadByte();

            mdlCorners[c].color.x = rrr;
            mdlCorners[c].color.y = ggg;
            mdlCorners[c].color.z = bbb;
            mdlCorners[c].color.w = aaa;

            mdlCorners[c].texCoord.u = br.ReadSingle(); 
            mdlCorners[c].texCoord.v = br.ReadSingle(); 
        }
            Console.WriteLine("Read " + header.cornerCount + " corners.");
    }

// ========================================================

    public void readSurfaces(BinaryReader br)
    {
        Console.WriteLine("\n====== readSurfaces() ===\n");

        if (header.textureCount == 0) // One texture per surface, it seems.
        {
            Console.WriteLine("No surfaces.");
            return;
        }

        var mdlSurfaces = surfaces;

//      mdlSurfaces.resize(header.textureCount);
        for (int oo = 0; oo < header.textureCount; oo++)
        mdlSurfaces.Add(new SurfaceInfo());

        for (int s = 0; s < header.textureCount; ++s)
        {
            mdlSurfaces[s].textureName = br.readString();
            mdlSurfaces[s].startCorner = br.ReadInt32();
            mdlSurfaces[s].spanCorner  = br.ReadInt32();
            mdlSurfaces[s].cornerCount = br.ReadInt32();

            if (mdlSurfaces[s].cornerCount == 0)
            {
                continue;
            }

            var faceCount = (mdlSurfaces[s].cornerCount / 3); // Triangles (corner == vertex)

// íàäî     mdlSurfaces[s].faces.resize(faceCount);

            for (int oo = 0; oo < faceCount; oo++)
            mdlSurfaces[s].faces.Add(new TriIndex());

            for (int f = 0; f < faceCount; f++)
            {
                mdlSurfaces[s].faces[f].index[0] = br.ReadUInt16();
                mdlSurfaces[s].faces[f].index[1] = br.ReadUInt16();
                mdlSurfaces[s].faces[f].index[2] = br.ReadUInt16();
            }
        }
            Console.WriteLine("Read " + header.textureCount + " surfaces.");
    }

// ========================================================

}

//æææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææ
//æææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææ
//æææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææ

public struct FourCC // final
{
    public byte c0, c1, c2, c3;
};

//#pragma pack(push, 1)

	public class Header
	{
		// File id, always 'SNOD'.

		public FourCC magic;

		// Misc info and sizes:

		public int version;
		public int unused0;
		public int doorCount;
		public int spotCount;
		public int cornerCount;
		public int faceCount;
		public int textureCount;

		// AABBs for the whole mesh.

		public Vec3 minBBox = new Vec3();
		public Vec3 maxBBox = new Vec3();

		// Junk/not used. Why was this left here? I dunno...

		public int unused1;
		public int unused2;
		public int unused3;
		public int unused4;
		public int unused5;
		public int unused6;
		public int unused7;

		// CRC32 of the data, excluding this header.

		public int dataCrc32;
	};
	
//#pragma pack(pop)

// ========================================================

//#pragma pack(push, 1)

	public class TriIndex
	{
      // Unlike the ASP models, Siege Nodes use 16bits indexes.
      public ushort[] index = new ushort[3];
	}
	
//#pragma pack(pop)

//æææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææ

	public class SpotInfo
	{ 
      // 3x3 rotation matrix + translation vector.
      public float[,] xform = new float[4,3]; // float xform[4][3]; 
      public string name;
	}

// ========================================================

	public class DoorInfo
	{
      public int index = 0;
      // 3x3 rotation matrix + translation vector.
      public float[,] xform = new float[4,3]; // float xform[4][3]; 
      public List<int> hotSpots = new List<int>();
	}

// ========================================================

	// Corners are the interleaved models vertexes.
	// The Max scripts used the term corners to mean a vertex.

	public class CornerInfo
	{
      public Vec2  texCoord = new Vec2();
      public Vec3  pos = new Vec3();
      public Vec3  normal = new Vec3();
      
    //NOTE: Stored as RBGA in the file! 
    //We swizzle back to RGBA on load.

      public Vec4b color = new Vec4b(); 
	}

// ========================================================

	public class SurfaceInfo
	{
      public int startCorner;
      public int spanCorner;
      public int cornerCount;
      public List<TriIndex> faces = new List<TriIndex>();
      public string textureName;
	}

//æææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææ

  public sealed class Vec2
  {
      public float u { get; set; }
      public float v { get; set; }
  }

// ========================================================

  public sealed class Vec3
  {
      public float x { get; set; }
      public float y { get; set; }
      public float z { get; set; }
  }

// ========================================================

  public sealed class Vec4
  {
      public float x { get; set; }
      public float y { get; set; }
      public float z { get; set; }
      public float w { get; set; }
  }

// ========================================================

  public sealed class Vec4b
  {
      public byte x { get; set; }
      public byte y { get; set; }
      public byte z { get; set; }
      public byte w { get; set; }
  }

//æææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææææ
